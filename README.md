# devops-netology

1) Результат выполнения операции следующий.

```bash
vagrant@vagrant:~$ a=1
vagrant@vagrant:~$ b=2
vagrant@vagrant:~$ c=a+b
vagrant@vagrant:~$ d=$a+$b
vagrant@vagrant:~$ e=$(($a+$b))
vagrant@vagrant:~$ echo $c
a+b
vagrant@vagrant:~$ echo $d
1+2
vagrant@vagrant:~$ echo $e
3
```
Для переменных a и b присваиваются значения 1 и 2. Для переменной c присваивается значение a+b, т.к. в данном случае это не сумма переменных a и b, 
а строковое выражение (для этого нужно указать знак доллара). Для переменной d значение получается 1+2, т.к. переменные a и b возвращают значения, которые хранят.
Однако в данном случае само выражение $a+$b будет являться не суммой, а также строковым литералом, в который добавили значения переменных a и b. Переменная e выводит результат 3,
т.к. выражение (()) получает значение, которое выполнено выражение внутри скобок (в данном случае $a+$b), присваивая значение 3.

2) Скрипт не запустится, как минимум из-за того, что само выражение ((1==1) ошибочно, пропущена одна скобка. Условие [[ 1==1 ]] всегда будет равно true, 
из-за чего цикл while никогда не прекратится. Если не использовать дополнительных переменных, то для завершения скрипта можно использовать оператор break, например:

```bash
while [[ 1==1 ]]
do
  curl https://localhost:4757
    if (($? != 0))
      then
        date >> curl.log
      else
        break
    fi
done
```

3) Выполнено.

```bash
#!/bin/bash

arr=(192.168.0.1 173.194.222.113 87.250.250.242)

for i in {1..5}
do
  for address in "${arr[@]}"
  do
    curl -s --connect-timeout 5 "$address":80 >> ping.log
  done
done
```

4) Выполнено.

```bash
#!/bin/bash

arr=(192.168.0.1 173.194.222.113 87.250.250.242)

for i in {1..5}
do
  for address in "${arr[@]}"
  do
    curl -s --connect-timeout 5 "$address":80 >> ping.log
    if [[ $? != 0 ]]
      then
        echo "$address" >> error.log
    fi
  done
done
```